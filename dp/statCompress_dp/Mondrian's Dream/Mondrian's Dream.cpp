//first try:TLE
/*

#include<iostream>
#include<cstring>
using namespace std;
const int N=12,M=1<<N;

int f[N][M];//第N列的性质为M
//0代表没有突出来一块，s代表凸出来s块，有2^M个状态（000...~111...）

bool judge(int s)//用于判断形状s是否合法
{
    //即0必须为连续偶数个,数字&1可以得到最低位的二进制数
    int cnt=0;

    while(s)
    {
        int low_bit=s&1;
        s>>1;
        if(!low_bit) cnt++;
        else if(low_bit)
        {
            if(cnt%2==0) cnt=0;//清0
            if(cnt%2!=0) return false;//非法
        }
    }

    //注意最后一次判断比较特殊，因为可能不存在末尾1作为进行判断的标准
    if(cnt%2!=0) return false;

    return true;
}

void dp(int n,int m)
{
    //关键是思考如何进行状态定义和转移
    //将状态粗糙的定义为f[N][M],即N行M列
    //明显可以发现大状态和小状态直接是没有合适的转移关系的
    //所以要找有转移关系的状态，这要怎么做呢，如何去思考呢？
    //问题在于状态不够具体，状态越具体越容易转移
    //可是定义的越具体，状态表示貌似就越复杂（维度越大）
    //所以我要找关键的因素。。。直接想，想不出来
    //假设我就用f[N][M],增加一列，我去思考f[i][j]和f[i][j-1]的关系
    //显然在f[i][j-1]的基础上增加空白的一列，只能对应1种或0种f[i][j]的状态
    //所以知道f[i][j]大量的状态不是由f[i][j-1]直接转移而来的
    //而是由一些曲折的形状，即第j-1列没有填满的方式转移而来
    //分析到这里，我就明白了，如果把第j-1列填满和没有填满当作统一的方式对待
    //f[i][j]就只由i-1列的形状确定！！！
    //当列数不变，行增加时，是一样的道理
    //即f[i][j]由第i-1行的形状确定
    //所以状态定义包含行和列的形状这一信息。
    //貌似又有点不对，如果同时考虑行和列的形状，我还需要的行数和列数信息
    //而且仔细一想，我之前单独分析行和列的时候，
    //比如分析增加一列的时候，我默认只有j-1列曲折，
    //也就是说，j-1之前的列都被填满了。。。是我分析错了吗
    //没有问题，f[i][j]肯定只能由前面1~j-2列都填满的情况转移而来
    //1~j-2都填满，又要考虑第j-1列的形状
    //我只需要记录行数和第j-1列的形状就行了！！！
    //所以我定义为f[N][K][M],N代表行数，K代表第几列，M代表形状（数字和形状一一对应）
    //仔细一想，如果确定了M，那么N就不需要了
    //那么就定义为f[K][M]

    //清空之前的状态
    memset(f,0,sizeof f);
    
    //f[1][k]由f[0][s]转移而来,而f[0][s]无意义，没有第0列
    //这怎么办,f[1][k]只要k合法就算一种，可以特判写
    //这里如果统一理解，就是把f[0][s]的第0列当作有意义
    //因为第0列要对后面没影响，所以f[0][s]都初始化为0
    //但是f[0][0]不会有影响，定义为1
    f[0][0]=1;
    

    for(int j=1;j<=m;j++)
    {
        for(int k=1;k<(1<<n);k++)
        {
            for(int s=0;s<(1<<n);s++)
            {
                //这里要思考f[j][k]和f[j-1][s]直接是否能进行转移
                //f[j][k]状态下第j-1列是满的，f[j-1][s]代表第j-1列形状为s
                //若想由前一列的s转移为当前列的k，对于二进制表示的k(0有，1无)
                //当前列的每个1之必定是由上一列的0，再放上一个1x2的长方形的到d
                //所以两列必须0,1交错，即k&s=0
                //并且若第j列的形状k若为非法形状（即不能凑2X1图形填满）
                //它永远不可能成为转移为后面大状态的子状态
                //所以要保证f[a][b]的b形状总是合法
                if(judge(k)&&judge(s)&& !(k&s))
                    f[j][k]+=f[j-1][s];
            }
        }
    }
}

int main()
{
    int n,m;
    while(scanf("%d%d",&n,&m),!(n|m))
    {
        dp(n,m);
        printf("%d\n",f[m][1<<n-1]);
    } 

    return 0;
}

*/

//second try
//我预处理下judge的那些值，并存储起来，这样不用重复调用judge
#include<iostream>
#include<cstring>
using namespace std;
const int N=12,M=1<<N;

long long f[N][M];//第N列的性质为M
//0代表没有突出来一块，s代表凸出来s块，有2^M个状态（000...~111...）

bool st[M];

void dp(int n,int m)
{
    //关键是思考如何进行状态定义和转移
    //将状态粗糙的定义为f[N][M],即N行M列
    //明显可以发现大状态和小状态直接是没有合适的转移关系的
    //所以要找有转移关系的状态，这要怎么做呢，如何去思考呢？
    //问题在于状态不够具体，状态越具体越容易转移
    //可是定义的越具体，状态表示貌似就越复杂（维度越大）
    //所以我要找关键的因素。。。直接想，想不出来
    //假设我就用f[N][M],增加一列，我去思考f[i][j]和f[i][j-1]的关系
    //显然在f[i][j-1]的基础上增加空白的一列，只能对应1种或0种f[i][j]的状态
    //所以知道f[i][j]大量的状态不是由f[i][j-1]直接转移而来的
    //而是由一些曲折的形状，即第j-1列没有填满的方式转移而来
    //分析到这里，我就明白了，如果把第j-1列填满和没有填满当作统一的方式对待
    //f[i][j]就只由i-1列的形状确定！！！
    //当列数不变，行增加时，是一样的道理
    //即f[i][j]由第i-1行的形状确定
    //所以状态定义包含行和列的形状这一信息。
    //貌似又有点不对，如果同时考虑行和列的形状，我还需要的行数和列数信息
    //而且仔细一想，我之前单独分析行和列的时候，
    //比如分析增加一列的时候，我默认只有j-1列曲折，
    //也就是说，j-1之前的列都被填满了。。。是我分析错了吗
    //没有问题，f[i][j]肯定只能由前面1~j-2列都填满的情况转移而来
    //1~j-2都填满，又要考虑第j-1列的形状
    //我只需要记录行数和第j-1列的形状就行了！！！
    //所以我定义为f[N][K][M],N代表行数，K代表第几列，M代表形状（数字和形状一一对应）
    //仔细一想，如果确定了M，那么N就不需要了
    //那么就定义为f[K][M]

    //清空之前的状态
    memset(f,0,sizeof f);
    
    //f[1][k]由f[0][s]转移而来,而f[0][s]无意义，没有第0列
    //这怎么办,f[1][k]只要k合法就算一种，可以特判写
    //这里如果统一理解，就是把f[0][s]的第0列当作有意义
    //因为第0列要对后面没影响，所以f[0][s]都初始化为0
    //但是f[0][0]不会有影响，定义为1
    f[0][0]=1;
    

    for(int j=1;j<=m;j++)
    {
        for(int k=0;k<(1<<n);k++)
        {
            for(int s=0;s<(1<<n);s++)
            {
                //这里要思考f[j][k]和f[j-1][s]直接是否能进行转移
                //f[j][k]状态下第j-1列是满的，f[j-1][s]代表第j-1列形状为s
                //若想由前一列的s转移为当前列的k，对于二进制表示的k(0有，1无)
                //当前列的每个1之必定是由上一列的0，再放上一个1x2的长方形的到d
                //所以两列必须0,1交错，即k&s=0
                //并且若第j列的形状k若为非法形状（即不能凑2X1图形填满）
                //它永远不可能成为转移为后面大状态的子状态
                //所以要保证f[a][b]的b形状总是合法
                if (st[k] && st[s] && !(k & s))
                    f[j][k]+=f[j-1][s];
            }
        }
    }
}

int main()
{
    int n,m;

    while(scanf("%d%d",&n,&m),n||m)
    {
        //预处理
        for(int s=0;s<(1<<n);s++)
        {
            //即0必须为连续偶数个,数字&1可以得到最低位的二进制数
            int cnt=0;
            st[s]=true;

            for(int i=0;i<n;i++)
            {
                int low_bit=(s>>i)&1;
                if(!low_bit) cnt++;
                else if(low_bit)
                {
                    if(cnt%2!=0){
                        st[s]=false;//非法
                        break;
                    }

                    cnt=0;
                }
            }

            //注意最后一次判断比较特殊，因为可能不存在末尾1作为进行判断的标准
            if(cnt%2!=0) st[s]=false;

        }

        dp(n,m);
        printf("%lld\n",f[m][0]);
    } 

    return 0;
}